on:
  push:
    branches:
      - main
    paths:
      - '.github/workflows/ci.yml'
      - 'deploy/**'
      - 'src/**'
      - 'tests/**'
      - 'examples/**'
  pull_request:
    paths:
      - '.github/workflows/ci.yml'
      - 'deploy/**'
      - 'src/**'
      - 'tests/**'
      - 'examples/**'
jobs:
  lint-and-unit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18.x'
      - name: Check code style
        run: |
          cd src
          npm ci
          npm run lint:check
      - name: Run unit tests
        run: |
          cd src
          npm run test
  build-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: |
            arm64
            amd64
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}/qdrant-operator
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ github.sha }}
      - name: Build and push docker images multi-arch amd64 and arm64
        uses: docker/build-push-action@v5
        with:
          context: src/
          file: src/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
  integration-test:
    runs-on: ubuntu-latest
    needs: build-image
    steps:
      - uses: actions/checkout@v4
      - name: Install K3S
        uses: nolar/setup-k3d-k3s@v1
        with:
          version: v1.32.11+k3s1
      - name: Install qdrant-operator
        run: |
          kubectl apply -f deploy/crds/
          IMAGE_TAG="ghcr.io/${{ github.repository }}/qdrant-operator:${{ github.sha }}"
          echo "Using image: ${IMAGE_TAG}"

          # Reduce replicas to 1 for CI to speed up and reduce resource usage
          sed -e "s|image: .*$|image: ${IMAGE_TAG}|" \
              -e "s|replicas: 3|replicas: 1|" \
              deploy/operator.yaml | kubectl apply -f -

          echo "Waiting for deployment rollout (timeout: 120s)..."
          kubectl rollout status deploy/qdrant-operator -n qdrant-operator --timeout=120s || {
            echo "‚ùå Rollout failed or timed out. Checking pod status..."
            kubectl get pods -n qdrant-operator -l app=qdrant-operator
            echo ""
            echo "üìã Deployment description:"
            kubectl describe deployment qdrant-operator -n qdrant-operator
            echo ""
            echo "üìã Recent events:"
            kubectl get events -n qdrant-operator --sort-by='.lastTimestamp' | tail -20
            echo ""
            echo "üìã Pod descriptions:"
            kubectl get pods -n qdrant-operator -l app=qdrant-operator -o name | xargs -I {} kubectl describe {} -n qdrant-operator || true
            echo ""
            echo "üìã Pod logs:"
            kubectl get pods -n qdrant-operator -l app=qdrant-operator -o name | xargs -I {} kubectl logs {} -n qdrant-operator --tail=30 || true
            exit 1
          }

          echo "‚úÖ Deployment successful. Waiting for pod to be ready (timeout: 60s)..."
          kubectl wait --for=condition=ready pod -l app=qdrant-operator -n qdrant-operator --timeout=60s || {
            echo "‚ùå Pod not ready. Getting status..."
            kubectl get pods -n qdrant-operator -l app=qdrant-operator
            kubectl get pods -n qdrant-operator -l app=qdrant-operator -o name | xargs -I {} kubectl logs {} -n qdrant-operator --tail=30 || true
            exit 1
          }

          echo "üìã Verifying environment variables in pod..."
          POD_NAME=$(kubectl get pod -n qdrant-operator -l app=qdrant-operator -o jsonpath='{.items[0].metadata.name}')
          echo "   POD_NAME: ${POD_NAME}"
          # Wait a moment for container to be fully ready
          sleep 2
          # Try to verify env vars, but don't fail if it doesn't work (non-critical check)
          if kubectl exec -n qdrant-operator ${POD_NAME} -c operator -- env 2>/dev/null | grep -E "POD_NAME|POD_NAMESPACE"; then
            echo "‚úÖ Environment variables verified"
          else
            echo "‚ö†Ô∏è Warning: Could not verify environment variables (this is non-critical, pod is ready)"
          fi

          echo "üìã Getting operator logs..."
          kubectl logs -n qdrant-operator deploy/qdrant-operator --tail=50 || true

          echo "‚è≥ Waiting for operator to become leader (timeout: 30s)..."
          timeout=30
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            if kubectl logs -n qdrant-operator deploy/qdrant-operator --tail=10 2>/dev/null | grep -q "LEADER"; then
              echo "‚úÖ Operator is LEADER!"
              break
            fi
            echo "   Waiting for operator to become leader... (${elapsed}s/${timeout}s)"
            sleep 2
            elapsed=$((elapsed + 2))
          done

          if ! kubectl logs -n qdrant-operator deploy/qdrant-operator --tail=10 2>/dev/null | grep -q "LEADER"; then
            echo "‚ö†Ô∏è Warning: Operator may not be leader yet, but continuing..."
            kubectl logs -n qdrant-operator deploy/qdrant-operator --tail=20
          fi
      - name: Run E2E operator tests
        run: |
          chmod +x tests/e2e/*.sh

          echo "üß™ Running E2E test suite..."
          echo ""

          # Setup: Create cluster and collection
          tests/e2e/00-setup.sh

          # Happy path: Verify collection is accessible
          tests/e2e/10-happy-path.sh

          # Drift detection: Verify operator corrects manual changes
          tests/e2e/20-drift.sh

          # Idempotency: Verify no unnecessary rollouts
          tests/e2e/30-idempotency.sh

          # Finalizer: Verify proper cleanup (deletes cluster and collection)
          tests/e2e/40-finalizer.sh

          # Finalizer under load: Verify cleanup during cluster activity
          # Note: This test creates a new cluster/collection since the previous
          # test (40-finalizer.sh) deletes them. It tests the worst-case
          # scenario: deletion while cluster is under active use.
          tests/e2e/41-finalizer-under-load.sh

          # Leader failover: Verify HA behavior (optional, can be enabled if needed)
          # tests/e2e/50-leader-failover.sh

          echo ""
          echo "‚úÖ All E2E tests passed!"
