on:
  push:
    branches:
      - main
    paths:
      - '.github/workflows/ci.yml'
      - 'deploy/**'
      - 'src/**'
      - 'tests/**'
      - 'examples/**'
  pull_request:
    paths:
      - '.github/workflows/ci.yml'
      - 'deploy/**'
      - 'src/**'
      - 'tests/**'
      - 'examples/**'
jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18.x'
      - name: Install dependencies
        run: |
          cd src
          npm ci
      - name: Check code style
        run: |
          cd src
          npm run lint:check

  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18.x'
      - name: Install dependencies
        run: |
          cd src
          npm ci
      - name: Run unit tests
        run: |
          cd src
          npm run test
  build-image:
    runs-on: ubuntu-latest
    needs: [lint, unit-tests]
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: |
            arm64
            amd64
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}/qdrant-operator
          tags: |
            type=raw,value=${{ github.sha }}
      - name: Build and push docker images multi-arch amd64 and arm64 (test image)
        uses: docker/build-push-action@v5
        with:
          context: src/
          file: src/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
  # Core operator functionality tests
  e2e-core:
    runs-on: ubuntu-latest
    needs: build-image
    steps:
      - uses: actions/checkout@v4
      - name: Install K3S
        uses: nolar/setup-k3d-k3s@v1
        with:
          version: v1.32.11+k3s1
      - name: Install qdrant-operator
        run: |
          kubectl apply -f deploy/crds/
          IMAGE_TAG="ghcr.io/${{ github.repository }}/qdrant-operator:${{ github.sha }}"
          echo "Using image: ${IMAGE_TAG}"

          # Reduce replicas to 1 for CI to speed up and reduce resource usage
          sed -e "s|image: .*$|image: ${IMAGE_TAG}|" \
              -e "s|replicas: 3|replicas: 1|" \
              deploy/operator.yaml | kubectl apply -f -

          echo "Waiting for deployment rollout (timeout: 120s)..."
          kubectl rollout status deploy/qdrant-operator -n qdrant-operator --timeout=120s || {
            echo "‚ùå Rollout failed or timed out. Checking pod status..."
            kubectl get pods -n qdrant-operator -l app=qdrant-operator
            kubectl describe deployment qdrant-operator -n qdrant-operator
            kubectl get events -n qdrant-operator --sort-by='.lastTimestamp' | tail -20
            exit 1
          }

          echo "‚úÖ Deployment successful. Waiting for pod to be ready (timeout: 60s)..."
          kubectl wait --for=condition=ready pod -l app=qdrant-operator -n qdrant-operator --timeout=60s || {
            echo "‚ùå Pod not ready. Getting status..."
            kubectl get pods -n qdrant-operator -l app=qdrant-operator
            kubectl get pods -n qdrant-operator -l app=qdrant-operator -o name | xargs -I {} kubectl logs {} -n qdrant-operator --tail=30 || true
            exit 1
          }

          echo "‚è≥ Waiting for operator to become leader (timeout: 30s)..."
          POD_NAME=$(kubectl get pod -n qdrant-operator -l app=qdrant-operator -o jsonpath='{.items[0].metadata.name}')
          timeout=30
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            # Check Lease first (more reliable)
            HOLDER=$(kubectl get lease qdrant-operator -n qdrant-operator -o jsonpath='{.spec.holderIdentity}' 2>/dev/null || echo "")
            if [ "${HOLDER}" = "${POD_NAME}" ]; then
              echo "‚úÖ Operator is LEADER! (verified via Lease)"
              break
            fi
            # Fallback to logs
            if kubectl logs -n qdrant-operator "${POD_NAME}" --tail=10 2>/dev/null | grep -q "LEADER"; then
              echo "‚úÖ Operator is LEADER! (verified via logs)"
              break
            fi
            echo "   Waiting for operator to become leader... (${elapsed}s/${timeout}s)"
            sleep 2
            elapsed=$((elapsed + 2))
          done
      - name: Run core E2E tests
        run: |
          chmod +x tests/e2e/*.sh
          echo "üß™ Running Core E2E tests..."
          tests/e2e/00-setup.sh
          tests/e2e/10-happy-path.sh
          tests/e2e/20-drift.sh
          tests/e2e/30-idempotency.sh
          tests/e2e/70-invalid-spec.sh
          tests/e2e/80-periodic-reconcile-no-events.sh
          tests/e2e/85-metrics.sh
          # Upgrade compatibility test: use 'latest' as previous version, current SHA as current
          PREVIOUS_OPERATOR_VERSION=latest CURRENT_OPERATOR_VERSION=${{ github.sha }} tests/e2e/88-upgrade-compatibility.sh
          tests/e2e/90-spec-update-rollout.sh
          tests/e2e/95-rollback.sh
          echo "‚úÖ Core E2E tests passed!"
      - name: Capture operator logs (forensic status logs)
        if: always()
        run: |
          POD_NAME=$(kubectl get pod -n qdrant-operator -l app=qdrant-operator -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "${POD_NAME}" ]; then
            echo "üìã Capturing forensic status logs from operator..."
            echo "=== STATUS WRITE LOGS ==="
            kubectl logs -n qdrant-operator "${POD_NAME}" 2>/dev/null | grep -E "\[STATUS\]\[WRITE\]|\[STATUS\]\[VERIFY\]" | tail -100 || echo "No status logs found"
            echo ""
            echo "=== RECENT OPERATOR LOGS (last 50 lines) ==="
            kubectl logs -n qdrant-operator "${POD_NAME}" --tail=50 2>/dev/null || echo "Could not fetch logs"
          else
            echo "‚ö†Ô∏è Operator pod not found, cannot capture logs"
          fi

  # High Availability tests
  e2e-ha:
    runs-on: ubuntu-latest
    needs: build-image
    steps:
      - uses: actions/checkout@v4
      - name: Install K3S
        uses: nolar/setup-k3d-k3s@v1
        with:
          version: v1.32.11+k3s1
      - name: Install qdrant-operator
        run: |
          kubectl apply -f deploy/crds/
          IMAGE_TAG="ghcr.io/${{ github.repository }}/qdrant-operator:${{ github.sha }}"
          sed -e "s|image: .*$|image: ${IMAGE_TAG}|" \
              -e "s|replicas: 3|replicas: 1|" \
              deploy/operator.yaml | kubectl apply -f -
          kubectl rollout status deploy/qdrant-operator -n qdrant-operator --timeout=120s
          kubectl wait --for=condition=ready pod -l app=qdrant-operator -n qdrant-operator --timeout=60s
          POD_NAME=$(kubectl get pod -n qdrant-operator -l app=qdrant-operator -o jsonpath='{.items[0].metadata.name}')
          timeout=30
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            HOLDER=$(kubectl get lease qdrant-operator -n qdrant-operator -o jsonpath='{.spec.holderIdentity}' 2>/dev/null || echo "")
            if [ "${HOLDER}" = "${POD_NAME}" ] || kubectl logs -n qdrant-operator "${POD_NAME}" --tail=10 2>/dev/null | grep -q "LEADER"; then
              echo "‚úÖ Operator is LEADER!"
              break
            fi
            sleep 2
            elapsed=$((elapsed + 2))
          done
      - name: Run HA E2E tests
        run: |
          chmod +x tests/e2e/*.sh
          echo "üß™ Running HA E2E tests..."
          tests/e2e/00-setup.sh
          tests/e2e/50-leader-failover.sh
          tests/e2e/60-leader-failover-during-reconcile.sh
          tests/e2e/65-operator-crash-loop.sh
          echo "‚úÖ HA E2E tests passed!"
      - name: Capture operator logs (forensic status logs)
        if: always()
        run: |
          POD_NAME=$(kubectl get pod -n qdrant-operator -l app=qdrant-operator -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "${POD_NAME}" ]; then
            echo "üìã Capturing forensic status logs from operator..."
            echo "=== STATUS WRITE LOGS ==="
            kubectl logs -n qdrant-operator "${POD_NAME}" 2>/dev/null | grep -E "\[STATUS\]\[WRITE\]|\[STATUS\]\[VERIFY\]" | tail -100 || echo "No status logs found"
            echo ""
            echo "=== RECENT OPERATOR LOGS (last 50 lines) ==="
            kubectl logs -n qdrant-operator "${POD_NAME}" --tail=50 2>/dev/null || echo "Could not fetch logs"
          else
            echo "‚ö†Ô∏è Operator pod not found, cannot capture logs"
          fi

  # Cleanup and lifecycle tests
  e2e-cleanup:
    runs-on: ubuntu-latest
    needs: build-image
    steps:
      - uses: actions/checkout@v4
      - name: Install K3S
        uses: nolar/setup-k3d-k3s@v1
        with:
          version: v1.32.11+k3s1
      - name: Install qdrant-operator
        run: |
          kubectl apply -f deploy/crds/
          IMAGE_TAG="ghcr.io/${{ github.repository }}/qdrant-operator:${{ github.sha }}"
          sed -e "s|image: .*$|image: ${IMAGE_TAG}|" \
              -e "s|replicas: 3|replicas: 1|" \
              deploy/operator.yaml | kubectl apply -f -
          kubectl rollout status deploy/qdrant-operator -n qdrant-operator --timeout=120s
          kubectl wait --for=condition=ready pod -l app=qdrant-operator -n qdrant-operator --timeout=60s
          POD_NAME=$(kubectl get pod -n qdrant-operator -l app=qdrant-operator -o jsonpath='{.items[0].metadata.name}')
          timeout=30
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            HOLDER=$(kubectl get lease qdrant-operator -n qdrant-operator -o jsonpath='{.spec.holderIdentity}' 2>/dev/null || echo "")
            if [ "${HOLDER}" = "${POD_NAME}" ] || kubectl logs -n qdrant-operator "${POD_NAME}" --tail=10 2>/dev/null | grep -q "LEADER"; then
              echo "‚úÖ Operator is LEADER!"
              break
            fi
            sleep 2
            elapsed=$((elapsed + 2))
          done
      - name: Run cleanup E2E tests
        run: |
          chmod +x tests/e2e/*.sh
          echo "üß™ Running Cleanup E2E tests..."
          tests/e2e/00-setup.sh
          tests/e2e/40-finalizer.sh
          tests/e2e/41-finalizer-under-load.sh
          tests/e2e/100-delete-partial-cleanup.sh
          echo "‚úÖ Cleanup E2E tests passed!"
      - name: Capture operator logs (forensic status logs)
        if: always()
        run: |
          POD_NAME=$(kubectl get pod -n qdrant-operator -l app=qdrant-operator -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "${POD_NAME}" ]; then
            echo "üìã Capturing forensic status logs from operator..."
            echo "=== STATUS WRITE LOGS ==="
            kubectl logs -n qdrant-operator "${POD_NAME}" 2>/dev/null | grep -E "\[STATUS\]\[WRITE\]|\[STATUS\]\[VERIFY\]" | tail -100 || echo "No status logs found"
            echo ""
            echo "=== RECENT OPERATOR LOGS (last 50 lines) ==="
            kubectl logs -n qdrant-operator "${POD_NAME}" --tail=50 2>/dev/null || echo "Could not fetch logs"
          else
            echo "‚ö†Ô∏è Operator pod not found, cannot capture logs"
          fi

  # Feature tests (PVC, VolumeSnapshot)
  e2e-features:
    runs-on: ubuntu-latest
    needs: build-image
    steps:
      - uses: actions/checkout@v4
      - name: Install K3S
        uses: nolar/setup-k3d-k3s@v1
        with:
          version: v1.32.11+k3s1
      - name: Install qdrant-operator
        run: |
          kubectl apply -f deploy/crds/
          IMAGE_TAG="ghcr.io/${{ github.repository }}/qdrant-operator:${{ github.sha }}"
          sed -e "s|image: .*$|image: ${IMAGE_TAG}|" \
              -e "s|replicas: 3|replicas: 1|" \
              deploy/operator.yaml | kubectl apply -f -
          kubectl rollout status deploy/qdrant-operator -n qdrant-operator --timeout=120s
          kubectl wait --for=condition=ready pod -l app=qdrant-operator -n qdrant-operator --timeout=60s
          POD_NAME=$(kubectl get pod -n qdrant-operator -l app=qdrant-operator -o jsonpath='{.items[0].metadata.name}')
          timeout=30
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            HOLDER=$(kubectl get lease qdrant-operator -n qdrant-operator -o jsonpath='{.spec.holderIdentity}' 2>/dev/null || echo "")
            if [ "${HOLDER}" = "${POD_NAME}" ] || kubectl logs -n qdrant-operator "${POD_NAME}" --tail=10 2>/dev/null | grep -q "LEADER"; then
              echo "‚úÖ Operator is LEADER!"
              break
            fi
            sleep 2
            elapsed=$((elapsed + 2))
          done
      - name: Run features E2E tests
        run: |
          chmod +x tests/e2e/*.sh
          echo "üß™ Running Features E2E tests..."
          tests/e2e/00-setup.sh
          tests/e2e/110-pvc-auto-resize.sh
          tests/e2e/120-volumesnapshot-manual.sh
          tests/e2e/130-volumesnapshot-scheduled.sh
          echo "‚úÖ Features E2E tests passed!"
      - name: Capture operator logs (forensic status logs)
        if: always()
        run: |
          POD_NAME=$(kubectl get pod -n qdrant-operator -l app=qdrant-operator -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "${POD_NAME}" ]; then
            echo "üìã Capturing forensic status logs from operator..."
            echo "=== STATUS WRITE LOGS ==="
            kubectl logs -n qdrant-operator "${POD_NAME}" 2>/dev/null | grep -E "\[STATUS\]\[WRITE\]|\[STATUS\]\[VERIFY\]" | tail -100 || echo "No status logs found"
            echo ""
            echo "=== RECENT OPERATOR LOGS (last 50 lines) ==="
            kubectl logs -n qdrant-operator "${POD_NAME}" --tail=50 2>/dev/null || echo "Could not fetch logs"
          else
            echo "‚ö†Ô∏è Operator pod not found, cannot capture logs"
          fi

  # API REST tests
  e2e-api:
    runs-on: ubuntu-latest
    needs: build-image
    steps:
      - uses: actions/checkout@v4
      - name: Install K3S
        uses: nolar/setup-k3d-k3s@v1
        with:
          version: v1.32.11+k3s1
      - name: Install qdrant-operator
        run: |
          kubectl apply -f deploy/crds/
          IMAGE_TAG="ghcr.io/${{ github.repository }}/qdrant-operator:${{ github.sha }}"
          sed -e "s|image: .*$|image: ${IMAGE_TAG}|" \
              -e "s|replicas: 3|replicas: 1|" \
              deploy/operator.yaml | kubectl apply -f -
          kubectl rollout status deploy/qdrant-operator -n qdrant-operator --timeout=120s
          kubectl wait --for=condition=ready pod -l app=qdrant-operator -n qdrant-operator --timeout=60s
          POD_NAME=$(kubectl get pod -n qdrant-operator -l app=qdrant-operator -o jsonpath='{.items[0].metadata.name}')
          timeout=30
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            HOLDER=$(kubectl get lease qdrant-operator -n qdrant-operator -o jsonpath='{.spec.holderIdentity}' 2>/dev/null || echo "")
            if [ "${HOLDER}" = "${POD_NAME}" ] || kubectl logs -n qdrant-operator "${POD_NAME}" --tail=10 2>/dev/null | grep -q "LEADER"; then
              echo "‚úÖ Operator is LEADER!"
              break
            fi
            sleep 2
            elapsed=$((elapsed + 2))
          done
      - name: Run API E2E tests
        run: |
          chmod +x tests/e2e/*.sh
          echo "üß™ Running API E2E tests..."
          tests/e2e/00-setup.sh
          tests/e2e/140-api-collections.sh
          tests/e2e/150-api-restore.sh
          tests/e2e/160-api-authentication.sh
          tests/e2e/170-api-templates.sh
          tests/e2e/180-api-integration.sh
          echo "‚úÖ API E2E tests passed!"
      - name: Capture operator logs (forensic status logs)
        if: always()
        run: |
          POD_NAME=$(kubectl get pod -n qdrant-operator -l app=qdrant-operator -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -n "${POD_NAME}" ]; then
            echo "üìã Capturing forensic status logs from operator..."
            echo "=== STATUS WRITE LOGS ==="
            kubectl logs -n qdrant-operator "${POD_NAME}" 2>/dev/null | grep -E "\[STATUS\]\[WRITE\]|\[STATUS\]\[VERIFY\]" | tail -100 || echo "No status logs found"
            echo ""
            echo "=== RECENT OPERATOR LOGS (last 50 lines) ==="
            kubectl logs -n qdrant-operator "${POD_NAME}" --tail=50 2>/dev/null || echo "Could not fetch logs"
          else
            echo "‚ö†Ô∏è Operator pod not found, cannot capture logs"
          fi

  # Publish final Docker image tags only after all tests pass
  publish-image:
    runs-on: ubuntu-latest
    needs: [build-image, e2e-core, e2e-ha, e2e-cleanup, e2e-features, e2e-api]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}/qdrant-operator
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest
      - name: Tag and push final docker images
        run: |
          SOURCE_IMAGE="ghcr.io/${{ github.repository }}/qdrant-operator:${{ github.sha }}"
          echo "${{ steps.meta.outputs.tags }}" | while read -r tag; do
            if [ -n "$tag" ]; then
              echo "Tagging $SOURCE_IMAGE as $tag"
              docker buildx imagetools create --tag "$tag" "$SOURCE_IMAGE"
            fi
          done
